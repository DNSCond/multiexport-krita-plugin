from krita import *
import os
import json
import zipfile
from io import BytesIO
import tempfile
from PyQt5.QtWidgets import QMessageBox, QApplication

class MultiExport(Extension):
    def __init__(self, parent):
        super().__init__(parent)

    def setup(self):
        pass

    def createActions(self, window):
        action = window.createAction("export_layerzip", "Export as LayerZip (No-Crash)", "tools/scripts")
        action.triggered.connect(self.export_layerzip)

    def export_layerzip(self):
        doc = Krita.instance().activeDocument()
        if not doc: return

        # Ensure the file is saved so we have a path
        full_path = doc.fileName()
        if not full_path:
            if not doc.saveAs():
                return
            full_path = doc.fileName()

        folder = os.path.dirname(full_path)
        base_name = os.path.splitext(os.path.basename(full_path))[0]
        lzip_path = os.path.join(folder, f"{base_name}.lzip")

        # Record visibility to restore later
        visibility_map = {}
        def store_visibility(nodes):
            for n in nodes:
                visibility_map[n.uniqueId()] = n.visible()
                if n.childNodes(): store_visibility(n.childNodes())
        
        store_visibility(doc.topLevelNodes())

        mem_zip = BytesIO()
        layers_json = {"layers": [], "width": doc.width(), "height": doc.height()}

        try:
            with zipfile.ZipFile(mem_zip, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
                for node in doc.topLevelNodes():
                    # process_node returns the layer data
                    res = self.process_node_recursive(node, [], zf)
                    if res:
                        layers_json["layers"].append(res)
                
                zf.writestr("lzip.conf.json", json.dumps(layers_json, indent=2))

            with open(lzip_path, "wb") as f:
                f.write(mem_zip.getvalue())

            QMessageBox.information(None, "Success", f"LayerZip created at:\n{lzip_path}")

        except Exception as e:
            QMessageBox.critical(None, "Error", f"Failed: {str(e)}")
        finally:
            # Restore visibility
            def restore_visibility(nodes):
                for n in nodes:
                    if n.uniqueId() in visibility_map:
                        n.setVisible(visibility_map[n.uniqueId()])
                    if n.childNodes(): restore_visibility(n.childNodes())
            
            restore_visibility(doc.topLevelNodes())
            doc.refreshProjection()

    def process_node_recursive(self, node, path_list, zf):
        node_name = node.name()
        # Clean the name for Windows file paths
        safe_name = "".join([c for c in node_name if c.isalnum() or c in (' ', '_')]).strip().replace(" ", "_")
        
        if node.type() == "grouplayer":
            children_data = []
            for child in node.childNodes():
                res = self.process_node_recursive(child, path_list + [safe_name], zf)
                if res: children_data.append(res)
            return {"name": node_name, "type": "group", "layers": children_data}
        
        elif node.type() in ("paintlayer", "vectorlayer"):
            zip_path = "/".join(path_list + [f"{safe_name}.png"])
            
            # Using a temp file for the export
            tmp_fd, tmp_file = tempfile.mkstemp(suffix=".png")
            os.close(tmp_fd)

            try:
                # Passing this InfoObject is usually enough to skip the popup
                # even without setBatchmode(True)
                info = InfoObject()
                info.setProperty("alpha", True)
                info.setProperty("compression", 9)
                info.setProperty("forceSRGB", False)
                
                # Export the layer
                node.save(tmp_file, 72, 72, info)
                
                # Let the UI update/process to prevent freezing
                QApplication.processEvents()
                
                with open(tmp_file, "rb") as f:
                    zf.writestr(zip_path, f.read())
            finally:
                if os.path.exists(tmp_file):
                    os.remove(tmp_file)
                    
            return {"name": node_name, "type": "layer", "path": zip_path}
        
        return None

Krita.instance().addExtension(MultiExport(Krita.instance()))